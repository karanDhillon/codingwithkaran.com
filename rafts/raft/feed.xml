<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-28T14:47:36-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Coding with Karan</title><subtitle>I am a Mobile Engineer who works for a Toronto based company called Homestars, Inc. I love working on android applications where I incorporate clean architecture along with  SOLID principles all enforced by a Test Driven Development (TDD) approach.</subtitle><author><name>Karan Dhillon</name></author><entry><title type="html">Navigation component in multi-module android apps</title><link href="http://localhost:4000/2020/05/11/navigation-component-in-multi-module-android-apps.html" rel="alternate" type="text/html" title="Navigation component in multi-module android apps" /><published>2020-05-11T00:00:00-04:00</published><updated>2020-05-11T00:00:00-04:00</updated><id>http://localhost:4000/2020/05/11/navigation-component-in-multi-module-android-apps</id><content type="html" xml:base="http://localhost:4000/2020/05/11/navigation-component-in-multi-module-android-apps.html">&lt;p&gt;&lt;img src=&quot;/assets/images/navigation-graph.png&quot; alt=&quot;Nav graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the introduction of Navigation component in android Jetpack library, a ton of features were offered to the developers to ease the pain of arduous Fragment transactions and manually managing the back stack. Sure one can still do it, but given the detail of the Navigation component’s API, it would be a smart idea to let the library do the heavy lifting.&lt;/p&gt;

&lt;p&gt;Some of the features that navigation component offers to the developers are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Automatic fragment Transactions.&lt;/li&gt;
  &lt;li&gt;Automatic Back stack management.&lt;/li&gt;
  &lt;li&gt;SafeArgs plugin offers Null checks and Type casts for passed arguments.&lt;/li&gt;
  &lt;li&gt;Single resource file for navigation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is no new information. What I want to talk about is something Google docs do not cover: How to implement Navigation Component in Multi-module applications.&lt;/p&gt;

&lt;p&gt;Before we discuss various cases of how your application will be configured, it would be a good idea to go through the basics of Navigation Component, which is out of scope for this article.&lt;/p&gt;

&lt;p&gt;For our application, the architecture we follow will be pretty simple:&lt;/p&gt;
&lt;center&gt;
    &lt;img src=&quot;/assets/images/ss.png&quot; alt=&quot;App module&quot; width=&quot;500&quot; align=&quot;center&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Keeping the Nav_graph in :APP module
 In our :app module, we can refer to every feature sub-module, So we can create the application’s navigation graph in their. However, this has one problem. The reason we modularize our apps is to segregate our application into small features. Our end goal is to simply  use :APP module as a place to integrate all these :FEATURE modules. If we create the whole app’s navigation in the :APP module, we will be derailing from that goal. Also, we will not be able to refer to SafeArgs generated classes because those classes will be generated per module. So if Feature1 wants to navigate to Feature2, we will not be able to make use of Feature2’s SafeArgs classes. Our whole navigation strategy would have to be explicitly defined in the :APP module itself.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keeping the Nav_graph of each Feature in the respective module
 Having the entire navigation plan per feature sounds like a good idea. Every feature will be well isolated from each other and will contain all the logic of its own navigation. There still, however, exists the problem of inter-module navigation. To work around that, we can for example, use Deep links, include the sub graphs in the main application’s graph and that way we will get automatic intent-filters. (NOTE: do not forget to register the App graph in the application’s manifesto).&lt;/p&gt;

    &lt;p&gt;However, once again, we lose the SafeArgs benefit. Plus, creating Deep links for every destination sounds cumbersome and error prone. Let us see how #3 is a better solution overall.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keeping the Nav_graph in :BASE module
 Keeping the Nav_graph in the :BASE module is the best approach among all of them. Having all the feature nav graphs included in the :BASE graph opens the applications entire navigation strategy to all the feature modules. This way we get all the benefits of SafeArgs and any feature can navigate to any other features. Sounds awesome, but what is the caveat?
 FragmentNavigator makes use of Reflection when it looks for SafeArgs generated classes and argument classes. :BASE module, being unaware of all the :FEATURE modules, will render false Lint checks for all the references we will make in the :BASE module. It will compile just fine though, but we lose the Android Studio working for viewing our app’s navigation flow. A small price to pay for a big victory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Karan Dhillon</name></author><summary type="html"></summary></entry><entry><title type="html">Keep your privates internal</title><link href="http://localhost:4000/2020/04/20/keep-your-private-internals.html" rel="alternate" type="text/html" title="Keep your privates internal" /><published>2020-04-20T00:00:00-04:00</published><updated>2020-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/20/keep-your-private-internals</id><content type="html" xml:base="http://localhost:4000/2020/04/20/keep-your-private-internals.html">&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt; default visibility modifier for its elements is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Protected&lt;/code&gt; means that those elements have package level visibility, which in turn means only elements in the same package are allowed to use the element marked with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt; visibility modifier. This made sure that your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classes&lt;/code&gt; present in a different package cannot accidently use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; from a different package. But here walks in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;, making the elements default visibility modifier &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;. Sounds like a small change, but its not. It’s a major change. A change which can cause havoc if you are not cautious with the way you are exposing your elements.First let me explain why &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt; did what &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt; did.&lt;/p&gt;

&lt;p&gt;You see back in the days when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt; was a new release, their default visibility modifier was indeed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;. Well it is actually called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt;, but it does the same thing. Marking a element &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt; means only files from the same module can access this element marked with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt;. Now that was a good java-to-kotlin mapping, as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt; always try to present itself as “the shorthand Java”. But then something happened. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; team at JetBrains started noticing a trend. They noticed that most of the users were ditching the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt; modifier and switching it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; modifier. This trend has to be a major spike because later they decided that they are making a change where the default visibility modifier is now going to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;. Their reasoning behind this change was that they want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt; to be a language which makes user type less for more. In order to do that and to not cause their customers this annoying switch from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;, they made &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; the new default. Now lets see this from the perspective of developers who are actually the customers and see how it harms us.&lt;/p&gt;

&lt;p&gt;The biggest mistake that was ever made in the IT industry was the invention of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;. Even the inventor of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; has said on multiple occasions that it was his biggest mistake. On a side note, I personally do not let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt; creep into my projects. I rather make an “Empty Object”, which can be used instead of marking anything as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;. Let’s get back on track though, that mistake was made by a person. Second biggest mistake in IT industry is unseen dependencies. These dependencies creep up in your code and makes change difficult. So it is the job of a developer to manage these dependencies and make sure only certain classes are exposed as part of a module’s public API as dependencies. This will at least make sure that there are certain number of exposures and make debugging faster. Now imagine if by default, you were given the feature where a class cannot be exposed by a different module, or the dependency cannot creep out of your module and then taken away. That has what happened in the case of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;. For example, let us say I make a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Validator&lt;/code&gt; class in my Domain layer. Technically, this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Validator&lt;/code&gt; class should only be used by the UseCase. But because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; by default, I would have to remember explicitly to mark this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Validator&lt;/code&gt; class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt;. This explicit marking of class as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;internal&lt;/code&gt; is actually more annoying because you know that is how it should be by default. Before extending a class you have to explicitly mark it &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;, so why not to use it in a different module as well. I have my doubts about why at one side we are enforcing something and on another we are easing things. Developers should be made aware of all their decisions, so if they mark a class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt; they know the dangers that come with it.&lt;/p&gt;</content><author><name>Karan Dhillon</name></author><summary type="html">Java default visibility modifier for its elements is protected. Protected means that those elements have package level visibility, which in turn means only elements in the same package are allowed to use the element marked with protected visibility modifier. This made sure that your classes present in a different package cannot accidently use class from a different package. But here walks in Kotlin, making the elements default visibility modifier public. Sounds like a small change, but its not. It’s a major change. A change which can cause havoc if you are not cautious with the way you are exposing your elements.First let me explain why kotlin did what kotlin did.</summary></entry><entry><title type="html">All about annotations and annotation processors</title><link href="http://localhost:4000/2020/04/16/all-about-annotations-and-annotation-processors.html" rel="alternate" type="text/html" title="All about annotations and annotation processors" /><published>2020-04-16T00:00:00-04:00</published><updated>2020-04-16T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/16/all-about-annotations-and-annotation-processors</id><content type="html" xml:base="http://localhost:4000/2020/04/16/all-about-annotations-and-annotation-processors.html">&lt;p&gt;&lt;img src=&quot;/assets/images/annotation-processing-rounds.png&quot; alt=&quot;Annotation processing rounds&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Annotations provide metadata to our code. This metadata is only relevant to the scope of development and to the developer. In the absence of an annotation, this metadata information would have to be “squeezed” in our code by other means, such as naming conventions for example. To save the source code from such travesties, Java came up with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Annotations API&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JAVA 1.5&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;version 5&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java 1.6&lt;/code&gt; brought complete annotations support). With the help of annotations, we can include this metadata information in different “elements” of our source code. These elements can be any of the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Classes&lt;/li&gt;
  &lt;li&gt;Interfaces&lt;/li&gt;
  &lt;li&gt;Class or interface properties&lt;/li&gt;
  &lt;li&gt;Class or interface methods&lt;/li&gt;
  &lt;li&gt;Variables&lt;/li&gt;
  &lt;li&gt;Other first class citizens of your language&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After you mark you elements with the desired annotations, the class goes to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; (Java Complier) as per the usual business. As expected, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; is unaware of these annotations and it needs some help in unfolding the meaning if these alien entities. That is where annotation processors come into play. Annotation processors unfold the true intent of their respective supported annotation and eventually passed the resulting class back to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;. At this point &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; is stuck in a loop, where each and every annotation must be resolved before it can produce the desired &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java classes&lt;/code&gt;. We will discuss in detail this loop and the entire cycle in detail later in the article. Let us first try to understand what annotations are and how you can create your own annotations.&lt;/p&gt;

&lt;h1 id=&quot;what-are-annotations&quot;&gt;What are annotations?&lt;/h1&gt;
&lt;p&gt;To understand what are annotations and why we need them, let us observe a case. Let’s assume we have two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classes&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;. Both of them have a overloaded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function&lt;/code&gt; called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;veryLongNameFunction()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;veryLongFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;function called in class A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;verylongFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;function called in class B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b.veryLongFunction()&lt;/code&gt;, class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; function would be called. That happens because of our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typo&lt;/code&gt; in class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;’s function name. Needless to say, this will lead to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run time error&lt;/code&gt; which is expensive. To turn it into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compile time check&lt;/code&gt;, we can mark this method in class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; with an annotation which can explicitly state that this is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;overrided&lt;/code&gt; method of its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;super class&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;veryLongFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;function called in class B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now, we will not get a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run time error&lt;/code&gt; as our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compiler&lt;/code&gt; will throw an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt; if we will try to use our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;override&lt;/code&gt; method by using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b.verylongFunction()&lt;/code&gt;, as it is not overriding anything. This is the power of annotations. They can be used in various ways, in our case for instance, we used an annotation as an explicit markup. You can use annotations for code generation as well, which is what most of the external libraries do when they offer you a set of annotations to sprinkle around in your codebase. With the help of these annotations, the library’s annotation processor will kick in during compile time and it will produce all the meta data and generate new code required for the library to work with, making your job as a developer easier. One such instance of such a library is Dagger(2.0). The only way dagger is able to create a “Directed Acyclic Graph” of your dependencies is  with the help of all the annotations the library requires you to put in your codebase, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@inject&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@provides&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@module&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;Now that we are aware of what annotations are and why they were needed in the first place, lets see how we can create our custom annotations and use them in our codebase.&lt;/p&gt;

&lt;h1 id=&quot;how-to-create-a-custom-annotation&quot;&gt;How to create a custom annotation&lt;/h1&gt;
&lt;p&gt;Let us suppose the name of our custom annotation is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myAnnotation&lt;/code&gt;. In order to create our custom annotation, we have to provide some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;meta information&lt;/code&gt; about our custom annotation. This meta information will explain the retention policy and the element to which our annotation will abide. This meta information can be added through the help of, you guessed it, annotations. Here is what these meta-annotations look like:&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RententionPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Target&lt;/code&gt;, we specify the type of element we will attach our annotation, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;variable&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;, etc.
In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Retention&lt;/code&gt;, we specify how long our annotation will be retained, i.e. either until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOURCE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLASS&lt;/code&gt;, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUNTIME&lt;/code&gt;. Retaining a annotation until runtime can allow us to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reflection&lt;/code&gt; to read the annotation’s data.&lt;/p&gt;

&lt;p&gt;There are three types of annotations we can create based on our needs:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Marker annotation, as it does not have any value:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RententionPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Annotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Single value annotation, as it has a function that returns one value:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RententionPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Annotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;If you dont want to use the argument name, then name the function as value:&lt;/p&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RententionPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Annotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Multi value annotation, as it has multiple functions that return a value:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RententionPolicy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Annotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFirstField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mySecondField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So now in order to annotate our element with our custom annotation, all we need to do is this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;For Marker annotation:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myAnnotation&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;For Single value annotation(named argument):
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myAnnotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;For Single value annotation(unnamed argument, where the name of the function is “value”):&lt;/p&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myAnnotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;For Multi value annotation:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myAnnotation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myFirstField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;String&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mySecondField&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Notice how our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;single value&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multi value&lt;/code&gt; annotation form can take arguments. These &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parameters&lt;/code&gt; have the same name as the function name defined in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interface&lt;/code&gt; and the data type they accept is the one the function returns. These arguments can be used by the annotation processor as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flags&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configuration parameters&lt;/code&gt; for any purpose you deem fit. You can also provide default values to these arguments in case if the arguments are not provided.&lt;/p&gt;

&lt;p&gt;There are certain rules you should be aware of if you are going to define your own custom annotations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Annotations cannot participate in inheritance.&lt;/li&gt;
  &lt;li&gt;Annotation’s functions should not contain any arguments.&lt;/li&gt;
  &lt;li&gt;Annotations cannot be generic or specify a throw clause.&lt;/li&gt;
  &lt;li&gt;Annotations must return: an enum, primitive type or an annotation, String, or Class object. They can also return an array of these types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let’s talk about annotation processors, what they are, what they do, how they do it, and how can we create our own custom annotation processor.&lt;/p&gt;

&lt;h1 id=&quot;annotation-processors&quot;&gt;Annotation Processors&lt;/h1&gt;
&lt;p&gt;Annotation processors work or kick in inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;(Java Compiler). We don’t have to opt into this. Just by having an annotation processor on our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classpath&lt;/code&gt; when our code is compiling, our annotation processor will run. It does so with the help of something called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service Loader&lt;/code&gt;, which finds the processors, and processors is the class that we will implement in order to create our custom one.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Let us create our own processor called “CustomProcessor” as below:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;The first function that we will implement is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getSupportedSourceVersion()&lt;/code&gt;, which will tell the level of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java&lt;/code&gt; coming in and the level of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java&lt;/code&gt; going out. It is a good idea to always support the latest version that our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; is running on.
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedSourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;latestSupported&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;The second function that we will implement is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getSupportedAnnotationTypes()&lt;/code&gt;, which tells &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; what the fully qualified names of the annotations we care about are. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; will only call our processor for the annotations that we tell it to.
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedSourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;latestSupported&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Overried&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedAnnotationTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;singelton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;The third function is the most important one is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process()&lt;/code&gt;:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedSourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;latestSupported&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Overried&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedAnnotationTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;singelton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoundEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Lets us understand what happens inside the process function.&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;We query our environment to get all the elements that our annotated with our annotation:
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoundEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// We query the types that are annotated with our annotations.&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// The returned elements are the ones marked with our Example Annotation.&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getElementsAnnotatedWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;We can use these collected elements, which could be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classes&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;variables&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;functions&lt;/code&gt;, use libraries called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javaPoet&lt;/code&gt; and produce &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java classes&lt;/code&gt;.
        &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoundEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getElementsAnnotatedWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;blockquote&gt;
      &lt;p&gt;One cool thing about annotation processors, besident code generation, is that they run in their own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JVM&lt;/code&gt;. Though you can not access source files and its dependencies as they are being compiled as well during the time our annotation processor is working, however, we can bring our own set of dependencies. This means that you can create &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;models&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;factories&lt;/code&gt;, etc. anything to make your annotation processor module clean and solid. This code will not contribute to the generated code and will only be scope to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JVM&lt;/code&gt; in which your annotation processor will be running on.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The fourth function that is present in the AbstractProcessor is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init(processingEnv: ProcessingEnvironment)&lt;/code&gt;. As expected, in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; we do all the initialization for our custom processor. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessingEnvironment&lt;/code&gt; is yet another interface which we will not discuss here, however it has two important functions that we should talk about:
 First is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun getMessenger(): Messenger&lt;/code&gt;, which returns us a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Messenger&lt;/code&gt; object. With the help of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Messenger&lt;/code&gt;, we can communicate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;warnings&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors&lt;/code&gt; back to the third party developer who is compiling in case there is an issue in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process()&lt;/code&gt; function. This is a good practice as in its absence, if an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception&lt;/code&gt; occurs, our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jvm&lt;/code&gt; in which our custom annotation processor is running will simply crash and produce a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backstack dump&lt;/code&gt;, which is not useful to the developer. We can also control how the third party developer will use our annotations by throwing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors&lt;/code&gt; that will force them to follow the rules we will lay down with respect to how to use our annotations.&lt;/p&gt;

    &lt;p&gt;Second is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun getFiler(): Filer&lt;/code&gt;, which returns us a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filer&lt;/code&gt; object. In short, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filer&lt;/code&gt; helps us to actually create and write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java files&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The last two we should look at are fun &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getElementUtils(): Elements&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun getTypeUtils(): Types&lt;/code&gt;. These methods return utility classes that we can use to work with elements of different types that we will receive based on where our annotation is placed on. An analogy here would be that of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;, which has the concept of parent and children elements. Similarly, in java we define our class as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeElement&lt;/code&gt;, variables as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VariableElement&lt;/code&gt;, and functions as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutableElement&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So the complete code for our custom annotation processor will look like this:&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AbstractProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedSourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SourceVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;latestSupported&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Overried&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getSupportedAnnotationTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;singelton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TypeElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RoundEnvironment&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getElementsAnnotatedWith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;processingEnv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ProcessingEnvironment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now let’s talk about how different annotation processors works together in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; with harmony.&lt;/p&gt;

&lt;h1 id=&quot;processing-rounds&quot;&gt;Processing Rounds&lt;/h1&gt;
&lt;p&gt;There is a cycle that is followed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;, which allows every annotation processor to generate code for the annotations it is open for. This is the order of that flow:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We mark the element that our annotation is open to.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javac&lt;/code&gt; will start compiling. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javac&lt;/code&gt; is already aware of all the other annotation processors presents, as we have put them in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;classpath&lt;/code&gt; which will be picked up by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceLoader&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javac&lt;/code&gt; will produce the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; files in the first processing round. As the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; has already processed the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; files, it is already aware of the annotations which were used. It will pass the control to the respective annotation processor now.&lt;/li&gt;
  &lt;li&gt;Now the annotation processor will start to do its job. Here, it may or may not produce additional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; files. For the sake of argument, let’s say our customer annotation processor generated a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; class which contains annotations to be used by some other annotation processor.&lt;/li&gt;
  &lt;li&gt;At this moment, all the original &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; files have been compiled. However, because of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; file generated by our customer annotation processor, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt; will detect this and will start another processing round.&lt;/li&gt;
  &lt;li&gt;This cycle will keep on going until no more &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; files have been generated and detected by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;.
It is a good idea to create domain specific models for the Elements we will process in the custom annotation processor’s process() function as it will make working on these elements easier. For example, if our annotation processor has a constraint that says “all the annotated classes must be in the same package”, then we can simply refer to the model’s package property instead of working on the element itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A fun closing remark: Remember in the beginning we said that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceLoader&lt;/code&gt; is the one that will find our custom annotation processor and load it into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javac&lt;/code&gt;. Well in order for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceLoader&lt;/code&gt; to do that, we have to create a certain file in a repository in our project. However, we can use a cool annotation processor called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AutoService&lt;/code&gt;. All we need to do is mark our custom annotation processor’s class with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@AutoService(Processor.class)&lt;/code&gt; and it will generate that repository in our project.&lt;/p&gt;</content><author><name>Karan Dhillon</name></author><summary type="html"></summary></entry><entry><title type="html">Closures in swift and lambdas in kotlin</title><link href="http://localhost:4000/2020/04/14/closures-in-swift-and-lambdas-in-kotlin.html" rel="alternate" type="text/html" title="Closures in swift and lambdas in kotlin" /><published>2020-04-14T00:00:00-04:00</published><updated>2020-04-14T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/14/closures-in-swift-and-lambdas-in-kotlin</id><content type="html" xml:base="http://localhost:4000/2020/04/14/closures-in-swift-and-lambdas-in-kotlin.html">&lt;p&gt;Kotlin and Swift are currently the top two choices of language for Android and iOS respectively. Both have been successfully adopted by their respective communities of developers who use these sharp languages to create some amazing pieces of work. Even though these two languages have their own trademark, underneath it is all the same with different names for legal purposes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Structures offered by Swift can be created as Data Structures in Kotlin by enforcing the kotlin classes to follow some rules.&lt;/li&gt;
  &lt;li&gt;Protocols in Swift is Interfaces in Kotlin.&lt;/li&gt;
  &lt;li&gt;Both languages allow functional programming.&lt;/li&gt;
  &lt;li&gt;Kotlin has sealed classes, however Swift has great Enum support.&lt;/li&gt;
  &lt;li&gt;Closures in Swift are Lambdas in Kotlin.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You get the idea. Though there are some pieces of differences here and there, these differences do not matter in the grand scheme. Today, we will take a look &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closures&lt;/code&gt; in swift, which are blood-brothers to “lambdas” in kotlin.&lt;/p&gt;

&lt;h1 id=&quot;closures-in-swift&quot;&gt;Closures in Swift&lt;/h1&gt;
&lt;p&gt;A closure in Swift is a anonymous function which can be passed around in the scope. What this means is that functions are treated as first class citizens, just like variables or objects in Object Oriented Programming(OOP) environment. A function in swift that accepts a function as one of its parameter looks like this:&lt;/p&gt;
&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;param1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;param2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;nv&quot;&gt;ourFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ourFunc&lt;/code&gt; is our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function&lt;/code&gt; passed as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parameter&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exampleFunction&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ourFunc&lt;/code&gt; will accept two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params&lt;/code&gt; of its own of the data type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and would return an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; type. Now to make it into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closure&lt;/code&gt;, we have to call our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exampleFunction&lt;/code&gt;. In order to do that, we will go through certain steps and transformations:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;we will call our function and provide all the params:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;no1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;no2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Here we are inside our 'ourFunc' can use no1 &amp;amp; no2 parameter&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Here’s where closures start to become a bit tricky. The swift compiler is smart enough to infer the type of the parameters that we will pass in the ‘ourFunc’, so omitting the data types will change nothing:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;again, we dont need to explicitly define the return data type as swift compiler can infer that as well:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;We also dont need to explicitly say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;, as that can also be infered like below:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Closures in swift allow us to pass anonymous parameters, as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$0&lt;/code&gt; for first param, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1&lt;/code&gt; for second param, and so on. So we can further simply our function call to:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Now lastly, swift allows us with a feature where if the closure is defined as the last parameter in a function, i.e. a trailing closure, we can take it out of the function’s parameter parentheses like below:
    &lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;exampleFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;param1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;param2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can imagine, someone who is not aware of closures or lambdas might get confused if they sees the form define in the 6th point. So any of the forms mentioned above can be used as they all mean the same thing. Its simply an anonymous function being passed as a parameter.&lt;/p&gt;

&lt;p&gt;Now let us take a look at Lambdas in kotlin and then you will realize how both closure and lambdas are the same thing.&lt;/p&gt;

&lt;h1 id=&quot;lambdas-in-kotlin&quot;&gt;Lambdas in Kotlin&lt;/h1&gt;
&lt;p&gt;A lambda expression is nothing but a shorthand way to define the structure of a function. Lets say we have a function as below:&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The same function can be defined as a Lambda expression as below:&lt;/p&gt;
&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A lambda expression tells us:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;What the types of parameters are and how many parameters do we have.&lt;/li&gt;
  &lt;li&gt;What is the return data type of the function.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just like in Swift, functions are treated as a “First class” citizens in kotlin. Which means that functions can be passed as parameters to another functions, functions can be the return type of another function and functions can be saved in a variable. Now lets see how we will pass a lambda function to a normal kotlin function as one of its parameter.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Lets say that our function will contain one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; parameter and one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lambda&lt;/code&gt; function parameter as below:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// We assume that our lambda function will return &quot;5&quot;.&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;stringReturnedFromLambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringReturnedFromLambda&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Note: It is not necessary to name our parameter “lambda”. It is being done to simplify.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Now when we will call myFunction, we will have to provide this lambda function on its calling. This lambda function simply has to follow the contract specified in the function definition. So we will get something like below:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;muFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;If we only have one parameter in our lambda, for example:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;stringReturnedFromLambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringReturnedFromLambda&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Then we dont need to explicitly define the parameters &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; like we did in #2. Below representation would be fine as well:&lt;/p&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;muFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;As you can see, for one parameter, we get something called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;it&lt;/code&gt;, which is nothing but our handle to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lambda parameter&lt;/code&gt;. You are free to give a name to this it, just like we did before:&lt;/p&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;muFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Now for the trailing lamda part, which means if the last parameter of a function is a lambda expression, then we can bring it out of the parameter parenthesis just like we did in case of closures:
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;muFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;We can shorten it by using it :&lt;/p&gt;
    &lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;muFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you see, both Closures and Lambdas are made to solve the same problem: Passing anonymous functions as parameter to another function. They might have different names because of belonging to two different languages, however they are one and the same thing.&lt;/p&gt;</content><author><name>Karan Dhillon</name></author><summary type="html">Kotlin and Swift are currently the top two choices of language for Android and iOS respectively. Both have been successfully adopted by their respective communities of developers who use these sharp languages to create some amazing pieces of work. Even though these two languages have their own trademark, underneath it is all the same with different names for legal purposes: Structures offered by Swift can be created as Data Structures in Kotlin by enforcing the kotlin classes to follow some rules. Protocols in Swift is Interfaces in Kotlin. Both languages allow functional programming. Kotlin has sealed classes, however Swift has great Enum support. Closures in Swift are Lambdas in Kotlin.</summary></entry><entry><title type="html">The morning after syndrome</title><link href="http://localhost:4000/2020/04/10/the-morning-after-syndrome.html" rel="alternate" type="text/html" title="The morning after syndrome" /><published>2020-04-10T00:00:00-04:00</published><updated>2020-04-10T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/10/the-morning-after-syndrome</id><content type="html" xml:base="http://localhost:4000/2020/04/10/the-morning-after-syndrome.html">&lt;p&gt;Anyone who has worked on a mid to large sized project, has experienced the phenomena when the changes you made for the day are not present the next day when you touch the codebase as your work got overwritten by someone else. This is what know as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“The Morning After Syndrome”&lt;/code&gt;. Today we will do the RCA for this and try to understand how we can solve this issue in our projects.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Root Cause – Presence of a Cyclic Dependency Graph in your components.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Cyclic-dependency-graph.png&quot; alt=&quot;Cyclic dependency graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the above diagram, you will notice that are our components are well laid and the dependencies flow from top to bottom. A change in the authorizer will not cause a change trigger in the database for example. The only component that needs to be rebuild are those that are directly dependent on our authorizer component, which in our case is the main component. This is what is called a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“Directed Acyclic Graph”&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“DAG”&lt;/code&gt; for short.&lt;/p&gt;

&lt;p&gt;Having your components laid out where they can be separately build and deployed is what an architect wants to achieve. This has several benefits as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Each component’s testing becomes easier and practical.&lt;/li&gt;
  &lt;li&gt;Teams will be able to migrate to new releases of that component as it is not strongly coupled with other components and most importantly.&lt;/li&gt;
  &lt;li&gt;Teams can work independently without overwriting each others work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This utopia, however can be seriously taken away by adding one simple dependency in the mix to our architecture, having ,for example, our entities depend on our authorizer.&lt;/p&gt;

&lt;p&gt;If a developer unknowingly creates a entity to be dependent on one of the classes in the authorizer component in order to not “duplicate” the code, we will have more problems than what this idea tried to solve in the first place. To realize the extent of damage done, let us imagine a scenario where our authorizer component had some new changes and needs to be redeployed just like we did in the beginning of this blogpost. However, this time there are lots of actors involved:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Entities and main components will be rebundled because of their direct dependencies on authorizer component.&lt;/li&gt;
  &lt;li&gt;Database and Interactor components will be rebundled because the entity component has changed. There could be a scenario where entity component is not even using this new code that was published in the authorizer component, however, it will still be rebuilt because of its direct dependency on authorizer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice how a single dependency has completely thwarted the architect’s effort to maintain their plugin style architecture. The developer’s original intent might be to use Permission class from the authorizer component, which is nothing than a Util class. However, in doing so, an entire component gets depended on another. The solution will be discussed later, but in our case this could have been simply avoided if the developer recreates the Permission util class in the entities package as well.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Read Sandi Metz’s &lt;a href=&quot;https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction&quot;&gt;Wrong abstraction&lt;/a&gt; article for further reference.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;
&lt;h4 id=&quot;apply-the-dependency-inversion-principle&quot;&gt;Apply the Dependency Inversion Principle&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Solution-1.png&quot; alt=&quot;Soultion 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our primary goal is to convert our cyclic graph back to DAG. In order to do that we have to resolve this new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entities to authorizer&lt;/code&gt; dependency. One solution is to apply dependency inversion principle. We can introduce a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPermission&lt;/code&gt; interface which will be part of entities component. Whichever entity class was previously directly referencing the permissions util class can now do so by using our new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPermissions&lt;/code&gt; interface. This will protect our entities component from knowing too much detail about how Permissions class is implemented in the authorizer component. There will also be no need to rebundle the entities component this time as there is no direct dependency.&lt;/p&gt;

&lt;h4 id=&quot;create-a-new-component-that-both-the-entities-and-authorizer-depends-upon&quot;&gt;Create a new component that both the entities and authorizer depends upon&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Solution-2.png&quot; alt=&quot;Soultion 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this solution, we simply move all the classes that are involved in entities and authorizer components into a new component. What we are doing here is simply separating what frequently changes from the part which doesnot. In terms of design patterns, we just applied the strategy pattern.&lt;/p&gt;

&lt;p&gt;Spawning new components is not the best approach as the new component might not make great sense in the grand scheme. Purists can argue over how it could lead to the violation of the Common Closure Principle – Classes that change together should be in the same component. However, applying this solution does give us our DAG back and gets rid of the cyclic nature our system was heading towards.&lt;/p&gt;

&lt;p&gt;It would make sense to take out some time at this point and explore what your components are composed of. You want to enjoy separation of concerns as long as the separations you make, make good sense in the long run. A good thought to keep in mind at this point would be how you will version your components for new releases. Too many versioning would allow slow adoption whereas less components would cause less reusability.  This is also known as “Cohesion principles tension diagram”.&lt;/p&gt;

&lt;p&gt;In the end, each architect has to decide which benefits they want to enjoy at the current moment. For now, reusability might not make much sense and coming out with new versions would. Later, reusing would more make sense than better adoption rate. What one does will depend on which state the architect wants the system to be.&lt;/p&gt;</content><author><name>Karan Dhillon</name></author><summary type="html">Anyone who has worked on a mid to large sized project, has experienced the phenomena when the changes you made for the day are not present the next day when you touch the codebase as your work got overwritten by someone else. This is what know as “The Morning After Syndrome”. Today we will do the RCA for this and try to understand how we can solve this issue in our projects.</summary></entry><entry><title type="html">Clean architecture</title><link href="http://localhost:4000/2020/04/07/clean-architecture.html" rel="alternate" type="text/html" title="Clean architecture" /><published>2020-04-07T00:00:00-04:00</published><updated>2020-04-07T00:00:00-04:00</updated><id>http://localhost:4000/2020/04/07/clean-architecture</id><content type="html" xml:base="http://localhost:4000/2020/04/07/clean-architecture.html">&lt;p&gt;Writing code is fun. Maintaining it is not so. Statistically speaking, most of a developer’s time goes into reading the code than writing it. It sounds counterintuitive but it’s actually not if you think about it.You can make new features after every sprint if you follow agile practices, however during that sprint period, you will still try to spend time understanding how this new feature will fit into the ‘grand scheme’ and spend most of your mind cycles thinking what needs to be changed and what doesn’t. I believe, that is where clean architecture comes into play.&lt;/p&gt;

&lt;p&gt;To simply put, Clean architecture is just a bunch of rules and principles that needs to be followed which eventually will keep your software ‘soft’, i.e. easy to change. Now for every platform, the architecture would change its shape, however, on higher level, if two projects are to follow clean architecture, it is easy to understand both no matter on which one you are working on. This leads us to creating a higher level policy for our applications.
Out of tons of principles, the most notable and famous ones are called the SOLID principles. The acronym stands for:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S – Single responsibility Principle.
O – Open/Closed Principle.
L – Liskov Substitution Principle.
I – Interface Segregation Principle.
D – Dependency Inversion Principle.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In my personal belief, what gives clean architecture its cleanliness is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“Dependency Inversion Principle”&lt;/code&gt;. In retrospect, all my problems in various projects used to happen because of low – level details creeping up into my high level policy. Change made in a small and far reached dependency somehow will start breaking how the view deals with a particular state. That happens because of these dependencies creeping their way up to places where they should not even exist. Out of these, the ones most hard to catch are called the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“Transitive Dependencies”&lt;/code&gt;, but let’s come back to the topic as explaining that will be going on a tangent.&lt;/p&gt;

&lt;p&gt;This post will not go into details about what SOLID principles are. A quick google search will suffice. I rather wants to talk about the meaty parts of the clean architecture itself. So let’s start with my favourite, which is DOMAIN.&lt;/p&gt;

&lt;h1 id=&quot;domain&quot;&gt;DOMAIN&lt;/h1&gt;

&lt;p&gt;Domain creates what is called the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“Enterprise Logic”&lt;/code&gt; in the realm of clean architecture. This means any logic that will live in your domain will be similar throughout your suite of applications. This could be your iOS, android, flutter, react native, web, etc. The point is, the stuff that lives here is independent of any platform. The logic in domain is its heart, and it mainly consists of two things:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entities
Use Cases
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Entities are, to put it simply, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POJO&lt;/code&gt; class. They hold the least amount of logic, and their sole reason of existence is to shape the data that will be used by all the other applications, or rather whatever application sits on the top. For example, if we are building a notes taking application, we will have a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Note&lt;/code&gt; entity which will look something like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Note&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice how there is no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; field, or any other &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;primary key&lt;/code&gt; field, or any annotation processor used. There is a reason behind all of this madness. And that is dependency.
Adding annotations or mutating our entities so they can be used for persistence is not our goal here, especially in the domain layer. Adding 3rd party dependency will weaken the heart of your architecture, as now your domain depends on the 3rd party module. Purists who follow clean architecture to its true core goes as far as creating custom mappers for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; and back to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON&lt;/code&gt; even though there are fully fledged 3rd party libraries such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GSON&lt;/code&gt; by google Inc. to do that. Including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GSON&lt;/code&gt; in entities, such as, would do not harm technically to your domain as the library is pretty stable and going nowhere. However, now you have a dependency in your domain, and in future if support to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GSON&lt;/code&gt; ceases to exist or changes, you would have to go and make changes to your entities, hence breaking the second rule of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SOLID&lt;/code&gt; principles, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPEN/CLOSED PRINCIPLE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Use cases are contracts that give us information about what sort of action will be taken with our entities. For example, following our note taking application, here what our use cases will look like:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IAddNoteUseCase
IDeleteNoteUseCase
IUpdateNoteUseCase
IGetNoteUseCase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Notice how each use case has a prefix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I&lt;/code&gt; in the beginning. That tells you that these use cases are interfaces and not actual implementation. The reason is again pretty simple, dependency. Ultimately, our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Presenter&lt;/code&gt;, which will live in the presentation layer, will use these use case classes. However, we don’t want our presenter to know how the use case are being implemented. Presenter should have no such knowledge, as it will never in its lifetime will try to change it. So why release this information in the first place. This is a good way to safeguard our implementations and this is what causes the presentation layer to be dependent on our domain layer and not the other way around. Even though run time dependency goes from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;presentation to domain&lt;/code&gt;, the source code dependency goes from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;presentation to use case implementation to IUseCase&lt;/code&gt;. In doing so, we  followed the dependency inversion principle.&lt;/p&gt;

&lt;p&gt;This simple feature is what every architect use to spin those dependencies that travel from one module to another and turn them 180′. Also, note how we have separated every use case into a single unit, hence following single responsibility principle and interface segregation principle.&lt;/p&gt;

&lt;p&gt;Use cases are typically composed of repositories which can help them pull all the models they need. Here, models means data that will be sent through us from various data sources. However, use cases will not be aware of these models, as the repositories will convert these models to entities and nicely serve it to our use case, which will simply propagate the result by wrapping it in a state object. Read &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;railway programming paradigm&lt;/code&gt; to learn more about it.&lt;/p&gt;

&lt;p&gt;Now let’s talk about the data layer.&lt;/p&gt;

&lt;h1 id=&quot;data&quot;&gt;DATA&lt;/h1&gt;

&lt;p&gt;Our Data layer usually consists of the following:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IRepositories
IDataSources
Models
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Needless to say, again we are only releasing the contract to the domain layer. Domain layer should only know what can be done, instead of how it is being done. Our repositories will be cleanly segregated based on the feature. Usually, our repositories will be made up of our local data source implementation, our remote data source implementation, and our custom network info class, which can act as a utility class for checking the network state of the application that is being implied Again, we will use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INetworkInfo&lt;/code&gt; as the only thing in our case, for instance, that we want to use is a helper method class,  which will return us a boolean based on the network state.&lt;/p&gt;

&lt;p&gt;Data sources is where we will put all our low-level details. Feel free to make use of annotations in the models and to use data persistence throughout your application. Your logic is very cleanly placed in a single place which is the repository. You can decide the order in which persistence will occur. A general rule of thumb is to fetch the active remote data, save it in local storage, and send the data to the upper layers. In a situation where network state is inactive, you can write the logic that can make this local storage data kick in, while you are still checking the network state in the background with exponential back off.&lt;/p&gt;

&lt;p&gt;Most of the work will be done by the data sources. The only thing we expect from our data sources is a model which should be non-null. Use all the tools at your disposal that your language provides you here. In cases where data sources fail to fetch a model, we can raise and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception&lt;/code&gt;. This raised &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception&lt;/code&gt; will be neatly caught in our repository. What we expect from out repository is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result&lt;/code&gt;. Now this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result&lt;/code&gt; can further have as many states as you want, but for simplicity, we can say that it is composed of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result&amp;lt;model, exception&amp;gt;&lt;/code&gt;, with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result.Success&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Result.error&lt;/code&gt; as its child classes. This can be easily used in the use cases to see what kind of response is provided be the repository and based on an error or a failure we can propagate it further to our views.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Read about “State Transition Machines” to understand more about the concept of states.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Read about “Sealed classes” or “Enums” to understand how we can create these state hierarchies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Last, but not the least, comes the presentation layer.&lt;/p&gt;

&lt;h1 id=&quot;presentation&quot;&gt;PRESENTATION&lt;/h1&gt;

&lt;p&gt;Our presentation layer will consist of the following:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Views
Presenters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you have multiple presenters working together and assisting a single view, feel free to use interfaces as we did to protect your view having a transitive dependency on your presenters. To keep things simple in our case, we will go ahead and simply create the concrete classes that hold the logic. In simple applications, this approach is fine as the flow of control usually goes from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;view to presenter&lt;/code&gt; all the time.&lt;/p&gt;

&lt;p&gt;Here we have multiple choices as we are at the edge of our architecture. Anything we do can be and should be easily swappable as this does not concern our other layers. Being an android developer, I see the trend of migration from MVP to MVVM (Yes I know MVI is the ‘new boom’. However, technically all the MVs are not architectures). With our clean architecture implemented, this migration is painless as all we would need to do is copy the code lying in presenter to our view model and switch it inside the view. We can now reap the benefits a viewmodel offers us, without worrying about how our data sources or repositories will change.&lt;/p&gt;

&lt;p&gt;This ability to switch different components without touching others is what clean architecture provides us. Now in theory, it sounds like an overkill and some might argue a lot of this can be achieved without implementing such modules. And you are right. All of the above can be done without all the segregation we have talked about so far. However, in doing so you will create an architecture nevertheless particularly unique to this application, and the understanding and complexities of this architecture will be implicit to those who created it. An average lifespan of a software developer in a company is 1-2 years, whereas the software being written usually lasts 5-6 years. That means for those 3-4 years, the new developers will be in a constant state of confusion and disapproval. Every code will be questioned by them as they will fail to realize how things were done the way they look in code right now. On the other hand, if everything is properly put in its own module and the architect keeps our good old friend dependencies in check, the boundaries will make clear sense. Even the new developers will pick up the project quickly and the thought of not leaking information along these boundaries will be clear. On top of that, putting Test Driven Development (TDD) in the mix will further provide strong documentation about each and every module, as per to say what it can do and what it can’t.&lt;/p&gt;

&lt;p&gt;As stated in the book with the eponymous title, making software is scientific and not mathematic. We are constantly trying to prove what our software cannot do, and not what it can do. And anything we fail to prove that it cannot do for a long time, hence become one of the features our software which it can do.&lt;/p&gt;</content><author><name>Karan Dhillon</name></author><summary type="html">Writing code is fun. Maintaining it is not so. Statistically speaking, most of a developer’s time goes into reading the code than writing it. It sounds counterintuitive but it’s actually not if you think about it.You can make new features after every sprint if you follow agile practices, however during that sprint period, you will still try to spend time understanding how this new feature will fit into the ‘grand scheme’ and spend most of your mind cycles thinking what needs to be changed and what doesn’t. I believe, that is where clean architecture comes into play.</summary></entry></feed>